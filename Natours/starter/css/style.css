/*
COLORS:

Light green: #7ed56f
Medium green: #55c57a
Dark green: #28b485

*/
/* Resets all browser specific margin and padding */
/* star selector selects all elements */
*,
*:after,
*:before {
  margin: 0;
  padding: 0;
  /* Inherits from body. Allows All elements to have box-szing */
  box-sizing: inherit; }

html {
  /* Setting font-size to be 10px will make it easy to calculate rem units for everything else */
  /* font-size: 10px; */
  /* Since browser font size is usually 16px and we effectively want font-size to be 10px. 62.5% of 16px will give us 10px*/
  font-size: 62.5%; }

body {
  /* Lato is referenced in the html doc as a link. sans-serif is backup */
  font-family: 'Lato', sans-serif;
  font-weight: 400;
  /* Convert all px units to rem */
  /* font-size: 16px;
    padding: 30px; */
  font-size: 1.6rem;
  padding: 3rem;
  color: #777;
  /* Border-box will include padding and border into calculation of width and height of elements */
  box-sizing: border-box;
  line-height: 1.7; }

.header {
  height: 95vh;
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url("../img/hero.jpg");
  /* Ensures that the background completely covers the element even if it has to cut or stretch */
  background-size: cover;
  /* Will not crop from the top of background when re-sizing. Will crop from all other sides */
  background-position: top;
  /* Clip path specifices visible region of element*/
  /* Polygon specifies all vertices. Percents are relative to original sizing of element. It is specifying 4 verices here*/
  /* Vertices are x y */
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
  /* Position relative can be understood as an anchor or reference point for children who have position absolute */
  position: relative; }
  .header__logo-box {
    /* Position absolute will start positioning from the nearest element whose position is relative. */
    /* In this case, .logo-box is positioned relative to .header */
    position: absolute;
    top: 4rem;
    left: 4rem;
    animation: fadeIn .5s ease-out; }
  .header__logo {
    /* Only need to specify 1 size dimension for imgs. Browser will calculate the other diemension. */
    height: 3.5rem; }
  .header__text-box {
    /* Position is relative to .header */
    position: absolute;
    /* Top and left here will position the top left corner of the element right at the middle of the screen */
    top: 40%;
    left: 50%;
    /* Trick to center element. -50% is relative to the element itself. This is to compensate for the positioning */
    transform: translate(-50%, -50%);
    /* Centers all text inside .text-box (including text inside h1, a, etc tags) */
    text-align: center; }

.heading-primary {
  color: #fff;
  text-transform: uppercase;
  margin-bottom: 6rem;
  /* Backface-visiblity defines if the backside of a transformed element is visible */
  /* Doesn't seem like I need it for the effect */
  /* backface-visibility: hidden; */ }
  .heading-primary--main {
    /* Will treat the span as a block. So it will start on a new line */
    display: block;
    font-size: 6rem;
    font-weight: 400;
    letter-spacing: 3.5rem;
    /* This can be shorthanded to: animation: moveInLeft 2s ease-out */
    /* Refers to the name of the keyframes animation you want to use */
    animation-name: moveInLeft;
    /* How long the animation will last for */
    animation-duration: 2s;
    /* Defines the where the speed ramp is for the animation */
    /* Ease out will slow down towards the end of the animation */
    animation-timing-function: ease-out; }
  .heading-primary--sub {
    display: block;
    font-size: 2rem;
    font-weight: 700;
    letter-spacing: 1.75rem;
    animation: moveInRight 2s ease-out; }

@keyframes fadeIn {
  from {
    opacity: 0; }
  to {
    opacity: 1; } }

/* Defines an animation called moveInLeft. */
@keyframes moveInLeft {
  /* Starting frame */
  0% {
    opacity: 0;
    transform: translateX(-10rem); }
  80% {
    transform: translate(1rem); }
  /* Ending frame */
  100% {
    opacity: 1;
    transform: translate(0); } }

/* Can also use "from" and "to" to refer to 0% and 100% */
@keyframes moveInRight {
  from {
    opacity: 0;
    transform: translateX(10rem); }
  80% {
    transform: translate(-1rem); }
  to {
    opacity: 1;
    transform: translate(0); } }

@keyframes moveInBottom {
  0% {
    opacity: 0;
    transform: translateY(3rem); }
  100% {
    opacity: 1;
    transform: translateY(0); } }

.btn {
  /* These are psuedo classes. */
  /* Psuedo classes are different states of an element. */
  /* :link is unvisited links */
  /* :visited is visited links */
  /* :hover is on hover */
  /* :active is when mouse is clicked on it */
  /* These pseudo classes must be applied in this order */
  /* This is a pseudo element. */
  /* Pseudo elements appear inside the element's innerHTML or content on the DOM */
  /* The idea here is to create an element behind the button of the same size. So that we can manipulate it for cool effects */ }
  .btn:link, .btn:visited {
    text-transform: uppercase;
    text-decoration: none;
    /* Inline elements normally do not allow for setting width, height, padding, margins. This inline-block allows it */
    /* Inline-block will not start a new line like a block element will */
    display: inline-block;
    /* Padding can be set because display is inline-block (since this is <a> is an inline element) */
    padding: 1.5rem 4rem;
    border-radius: 5rem;
    /* Transition will smoothly animate values that will change. Changes can be triggered by psuedo classes :hover, :active , etc*/
    /* This is saying: "For all CSS properties, smoothly animate the values within .2 seconds" */
    /* This needs to be applied to the "initial state" */
    transition: all .2s;
    position: relative;
    /* You can specify specically which value to smoothly animate like this: */
    /*  transition: transform .2s;  <- This is saying "for only the transform value, smoothly animate it within .2 seconds" */ }
  .btn:hover {
    transform: translateY(-0.3rem);
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
    /* CONFUSING! */
    /* Order is <class>:<pseudo class>::<pseudo element> */
    /* This is saying "I want to select the ::after element of .btn when it is hover state */ }
    .btn:hover::after {
      transform: scaleX(1.4) scaleY(1.6);
      /* This will make it fade out. */
      /* The actual fading is done by the transition property on the pseudo element */
      opacity: 0; }
  .btn:active {
    transform: translateY(-0.1rem);
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.2); }
  .btn--white {
    background-color: #fff;
    color: #777; }
    .btn--white::after {
      background-color: #fff; }
  .btn::after {
    /* Need to specify content property for pseudo elements to be displayed */
    content: "";
    background-color: #fff;
    /* Don't need this. This is inherited from .btn */
    /* display: inline-block; */
    /* Height and width are all relative to the original element */
    /* Setting height and width to 100% will make it the same size as .btn */
    height: 100%;
    width: 100%;
    border-radius: 5rem;
    /* Since this pseudo element will appear inside the .btn it will appear as if we added more content to the .btn */
    /* Instead we need this pseudo element to be in the exact same position as .btn hence position: absolute; top: 0; left: 0; */
    position: absolute;
    top: 0;
    left: 0;
    /* Will ensure that this psuedo element is behind the .btn */
    z-index: -1;
    transition: all .3s; }
  .btn--animated {
    /* .75s is delay. So this animation will happen after .75s has passed since loading */
    animation: moveInBottom .5s ease-out .75s;
    /* Animation fill mode: Configures what values are applied by the animation before and after it is executing. */
    /* Backwards will apply the first keyframe styles before animation starts  */
    /* If this is not applied, then the button will be visible, then dissapear for the animation. We want to button to start invisible. */
    /* CONFUSING! Not sure why this is not needed for the spans in the <h1> */
    animation-fill-mode: backwards; }

/* Section 3 Notes */
/* 

===== HOW ARE UNITS CONVERTED TO FINAL VALUE? ===== 

All calculations will result in a final px (percentages and relative units are always caluclated to px)
- % (fonts) = x% * (parent's font-size)
- % (distance) = x% (parent's computed width/height)
- em (fonts) = x * (parent's computed font size)
    - 3em = 3 * (parent's computed font size)
- em (distance) = x * (current element's font size)
- rem = x * (root computed font size)
- vh = x percent * viewport height
- vw = x percent * viewport width

- Browsers specify root font-size (user agent): 16px

- Properties related to text are all inherited (ie. font-size, line-height, etc)
- When a property is inherited. It gets the computed value of it's parent element
- If there is no cascaded value (declared value), it checks if it is inherited, if it is not inherited, it takes the default value

=====  USING REM INSTEAD OF PX ===== 

- Note: REM is not supported for older IE browsers. Use this method with caution

- It is good practice to always use rem units instead of px. This is to allow for things to scale up and down based on the root font-size instead of hard coding in pixels
- Using rem units instead of px will preserve spacing ratios between elements

===== POSITIONING ===== 

- Relative:
    - Considered "normal flow"
    - Elements are layed out in natural order according to code

- Floats:
    - Will take element out of normal flow and move it as far as possible towards parent container
    - Will stack on other floated elements
    - Will cause other elements to wrap around floated elements
    - Container will not adjust it's height to the element. This can be fixed with "clear fixes"

- Absolute:
    - Will take element out of normal flow and position it relative the nearest parent that is not statically positioned (ie. relative, absolute)
    - No impact on surrounding content or elements
    - Can overlap with surrounding elements

===== BEM ===== 

Block-Element-Modififer Notation

- BEM is a way to structure and build CSS classes in a composable way (component based)
- The notation is defined as follows:

<block>__<element>--<modifier>

- Block: standalone component that is meaningful on it's own
- Element: part of a block that has no standalone meaning
- Modifier: a different version of a block or element


===== SECTION 4 - SASS INTRO ===== 

- Sass is a CSS Pre-processor
    - Meaning that Sass is built on top of CSS that adds more features (ie. nesting, variables, functions)
    - To start using SASS (.scss files) we first need to configure it, and have it compile it down to CSS

Note: There is a different between SCSS and SASS. They're essentially the same thing with different syntaxes. SCSS is more similar to CSS and so converting it back to CSS visually is easier.

- SCSS allows us to use // for comments


Variables:
    - Define variable with $
        $variableName: #00000

Nesting:

    Before SCSS:

    .navigation li {
        ...
    }

    With SCSS:

    .navigation {
        li {
            ...
        }
    }

- & means the selector at this current point 

    .navigation {
        li {
            &:hover {
                // & refers to .navigation li
            }
        }
    }

- You can also use & literally as it will literally translate to the current selector

.btn {
    &--white {
        // This will translate to .btn--white, so you can move all the code in .btn--white in here
    }
}

.btn--white {

}



Mixins:
- Use mixins when you notice repeatable code
- a re-usable block of code
- kind of like a multi line variable

@mixin <mixin name> {
    <mixin content>
}

.example {
    @include <mixin name>
}

ie). Mixin for clear fixes

@mixin clearFix {
    &::after {
        content: "";
        clear: both;
        display: table;
    }
}

.example {
    @include clearFix; 
}

- Mixins can alo take in arguments

@mixin <mixin name>($<mixin arg name>) {
    text-decoration: none;
    color: $<mixin arg name>
}

==== Aside: Floats and clear fixes: ====

- elements that float do not naturally contribute to their containers height. To fix this issue, people use "clear fixes"

To make the container of floated elements have height to fit the content, you need to do the following to the container element:

.container::after {
    content: "";
    clear: both;
    display: table;
}

- This is a good candidate to be a mixin because this can be re-used in many unrelated containers

========================================


Functions:
- Functions can take in arguments and return a value

@function <function name>($arg, $arg2) {
    @return $arg, $arg2;
}


Extends;
- Very similar to mixins. As they have the ability to get rid of repeatable code.
- Allows you to extend css rules
- Use when pieces of code are "inherently or thematically" related (ie. all buttons, etc)

%<extendable name> {
    <extendable content>
}

.example {
    .li {
        @extend %<extendable name>;
    }
}

- NOTE: Extends and mixins will normally have no difference functionally. However the diffrence is in how they are compiled down to CSS.
- When you write @extend %<extendable name>; It is grabbing the current selector at that level and applying that selector to the set of rules defined in the extendable.
- When you write @include <mixin name>; you are simply copying the piece of mixin code into that selector


==== Installing SASS ====

- Install npm package: node-sass --save-dev

==== Compiling SASS to CSS ====

- Run node-sass script:
    node-sass <input file> <output file>
- Add -w flag to watch for scss changes
    node-sass <input file> <output file> -w
- Install live server (or use VSCode extension) to hot reload for file changes
    npm i live-server -g
- Run live server on root of project


*/
